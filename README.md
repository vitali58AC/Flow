34.8 Flow


~~~ 1. Создайте экран, который имеет EditText, RadioGroup.
В EditText вводится поисковый запрос на поиск фильмов.
RadioGroup содержит тип фильмов: movie, series, episode.
Пользователь выбирает тип, вводит название, и приложение
 совершает запрос к http://www.omdbapi.com (см. следующие пункты).
~~~ 2. Создайте Flow-обёртку над EditText и RadioGroup.
Создайте Flow из EditText, RadioGroup.
Создайте enum MovieType (MOVIE, SERIES, EPISODE).
Преобразуйте emit из RadioGroup в MovieType. Используйте оператор map.
Передайте два созданных Flow во ViewModel. Например, в
методе bind (queryFlow: Flow<String>, movieTypeFlow: Flow<MovieType>).
Внутри метода bind cоздайте Flow-цепочку, в которой значение EditText
(query) комбинируется с выбранным MovieType. На выходе должен
получиться Flow, где emit представляет из себя пару query to movieType.
Добавьте к скомбинированному Flow debounce.
~~~ 3. Запустите Flow. Используйте оператор launchIn. Сохраните job,
полученный от launchIn, внутри ViewModel. Не забудьте его отменить
при уничтожении view фрагмента. Для этого создайте метод у ViewModel,
внутри которого будет вызываться job.cancel().
~~~ Создайте репозиторий MovieRepository. При появлении нового эмита в
скомбинированном Flow вызовите suspend-функцию searchMovies внутри
репозитория, используйте оператор mapLatest.
~~~ SearchMovies обращается к http://www.omdbapi.com, получает фильмы в
соответствии с query, MovieType, сохранит результат в БД.
~~~ Найденные фильмы, которые возвращаются из searchMovies, отобразите в списке.
~~~ Обработайте ошибку отсутствия сети — searchMovies должен
возвращать фильмы из БД, которые соответствуют условию.
~~~ Создайте метод observeMovies в репозитории, который возвращает
Flow<List<Movie>>. Сделайте так, чтобы при добавлении фильмов
в БД Flow эмитил значения.
~~~ Для этого используйте возвращаемый тип Flow в методе Dao.
~~~ Используйте метод MovieRepository.observeMovies. Например,
создайте экран, который будет отображать актуальный список
фильмов из БД без перезагрузки.
По желанию создайте собственный оператор для Flow.
Чтобы понять, как это сделать, посмотрите на реализацию уже готовых операторов.
Начните с map.
~~~ По желанию используйте StateFlow внутри ViewModel вместо LiveData.

Критерии оценки

Flow источника данных доступен из репозитория.
При вводе новых данных в форму выполняющийся запрос отменяется.
При вводе формы используется debounce.
Два Flow (EditText, RadioGroup) комбинируются в один.
Для комбинации Flow используется подходящий оператор.
Для операций получения данных используются правильные coroutine dispatchers.
Выполнены все пункты в соответствии с заданием.

Как отправить задание на проверку

Используйте репозиторий android_basic
Скачайте изменения в репозитории на локальную машину.
Выполните домашнее задание в папке Flow.
Отправьте коммиты в удалённый репозиторий.